# 动态规划
> 递推公式从上往下想, 状态转移从下至上写
- []
## 0-1背包问题

### 题目描述

> 给一些物品a1,a2,a3...ai, 每个物品有重量w1,w2,w3..., 价值v1,v2,v3...,你有一个袋子承受最多重量为n, 求装的物品最大价值
- 注意一个物品只能选一次

### 思路概述
> 开一个二维数组用来存储允许第i个物品放的时候,允许最大容量c的时候的最大价值`dp[i][c]`

- 转移方程: `dp[i][c] = max(dp[i-1][c], dp[i-1][c-w[i-1]] + c[i])`
- 转移方程推导

> i从1到n, 表示我现在允许第i个物品可以放，你放不放? 如果放,要看看你允许的最大容量够吗, 如果够的话, 在跟如果不放的最大价值比较，取他们两个的最大值即为该处的最大值


|0|1|2|3|4|
|-|-|-|-|-|
|1|||||
|2|
|3|
|4|
### 复杂度
- 空间$O(i * c)$
- 时间$O(i * c)$
### 优化
> 将`dp[i][c]`变成`dp[j]`为一维数组, 转移方程变成了`dp[j] = max(dp[j-w[i]], dp[j])`, 时间$O(c)$

- 值得注意的是一维数组如果正序遍历，会造成一个物品放多次的现象，而倒序遍历却不会

### 示例代码
- [x] [P1048](../../luogu/P1048.cpp)
- [ ] [P1049](../../luogu/P1049.cpp)
- [ ] [P1060](../../luogu/P1060.cpp)
- [ ] [P1164](../../luogu/P1164.cpp)
- [ ] [P1507](../../luogu/P1507.cpp)

## 完全背包问题

### 题目描述
> 和0-1背包不同的时一个物品可以选多次
>
### 思路概述
> 与01背包不同的时一维数组应该正序遍历
## LCS最长公共子序列

## LIS最长上升子序列
-[x] [P1439](../../luogu/P1439.cpp)


## 递推

### 题目描述
[覆盖墙面](https://www.luogu.com.cn/problem/P1990)
[铺地毯](https://www.luogu.com.cn/problem/P1228)
[画三角形](https://www.luogu.com.cn/problem/solution/P1498)
### 思路概述
> 从上至下想递推公式, 从下至上写代码
> 怎么写dfs()?
```cpp
void dfs(int depth, int x ....){
    if (depth == 1){
        // code
    }else{
        // 根据递推公式来做事情
        // 如果有全局变量改变需要回溯
    }
}

```
            
### 示例代码
- [ ] [P1228铺地毯](../../luogu/P1228)
![](../../img/1.png)
- [ ] [P1990覆盖墙面](../../luogu/P1990.cpp)
- [ ] [P1498](../../luogu/P1498.cpp)
![413D04B441BE7F05436E663B9F1A3C69](https://raw.githubusercontent.com/yyds1w3/PicGo-images/main/img/413D04B441BE7F05436E663B9F1A3C69.jpg)

# 贪心
> 几乎都是O(n)级别, 找局部最优并且对下一个操作有利
## 区间调度问题
### 题目描述
> 一条线段上找有多个线段, 找不重叠的线段最多数目



### 思路概述
> 优先找右端点小的区间


### 示例代码
- [x] [P1803](../../luogu/P1803.cpp)

## 霍夫曼树

> 介绍: 给定一群叶节点(带权值), 构建二叉树, 使得根节点的权值最大
>
> 构建: 利用最小堆的结构, 每次合并最小节点
> 时间复杂度: O(nlogn)
$WPL = \sum_{i=1}^nw_il_i\\
w_i:叶子节点权值, l_i叶子节点到根节点路径长度$ 
- [x] [P1090](../../luogu/P1090.cpp)
- emm突然忘了怎么手写堆了

## 好题
- [ ] [P3817](../../luogu/P3817.cpp)
- [ ] [P5019](../../luogu/P5019.cpp)
> P5019题解
![](../../img/2.png)
# 模拟


- [ ] [P3952](../../luogu/P3952.cpp) 
- [ ] [P2482猪国杀](../../luogu/P2482.cpp)
- [ ] [P5358鸭棋](../../luogu//P5358.cpp)

# 排序

[基础算法实现](../../algorithm//sort.cpp)

```cpp
// STL的排序算法
#include <algorithm>

sort(a,a+n,cmp); cmp返回true则不变,false则交换相邻元素
nth_element(first,nth,last); nth前<=nth，nth后>nth，不保证子序列排序
stable_sort(a,a+n,cmp); 归并排序
```
## 归并排序

### 题目描述1

> 一个数组a1,a2,a3,a4,每次进行一次比赛, 每次比赛后需要重新排名, 问最后的赢家

### 思路概述

> 如果每次都要进行快速排序: 那么就要O(nlogn * 比赛轮数)TLE
> 观察可以发现: 我们先进行一次快速排序, 则玩家之间就有了顺序, 接下来赢家和输家之间仍然有序，我们只需要合并他们即可，进行$O(n * 比赛轮数)$

### 示例代码
[P1309](../../luogu/P1309.cpp)

### 题目描述2

> 给你一个数组, 需要找到逆序对($a_i > a_j \And i < j$)

### 思路概述

> 如果用双重循环, 时间复杂度$O(n^2)$TLE了, 故我们需要$nlogn$的算法,第一步分解排序, ==由下之上==来数逆序对, 递归树$h=logn$ 每次操作$n$: 右边的只要大于左边的一个较大元素,该左边的元素的左边元素与右边该元素全部是逆序对, 复杂度$O(nlogn)$

### 示例代码
- [ ] [P1908](../../luogu/P1908.cpp)

## 桶排序

- [ ] [P1059](../../luogu/P1059.cpp)

# 二分

> 当暴力枚举会TLE的时候就二分枚举$O(n) - > O(logn)$
> 要有单调性

```cpp
模板
while(l < r - 1){ // 注意踩坑的地方: 假如起始搜索是[1, 10000000], 那么最后的l >= 2, r >= 2 // 可能漏解, 故起始最好是0
    m = l - (l - r ) / 2;
    if (judge(m)){
        r = m; // 如果找满足条件的最小值就改变r， 否则改变l
    }else{
        l = m; // 同上
    }
    return r; // 返回judge的那个答案
}

```

-[ ] [P1873](../../luogu/P1873.cpp)

# 前缀和 & 差分

## 前缀和

### 题目描述

> 给你一个数组, 求区间和为7的倍数的最大连续区间长度

### 思路概述
原数组A, 前缀和s
- 前缀和公式$s_{i,j} = A_{i,j} + s_{i-1,j} + s_{i,j-1} - s_{i-1,j-1}$
- 前缀和还原公式$A_{i,j} = s_{i-1,j} + s_{i,j-1} - s_{i,j} - s_{i-1,j-1}$
> 首先, 区间和想到了一维前缀和, 使得在读入数据的时候就能把前缀和计算出来，时间复杂度$O(n)$, 然后想到区间和$a_i \to a_j = s_j - s_{i-1}$, 巧妙的是, 我们不需要把每个区间和$S_{i,j}$算出来存到二维数组,而是直接把$S_{1,j}$%7,观察结果里余数一样的,那么他们之间的区间和一定为7的倍数

### 示例代码
[P3131](../../luogu/P3131.cpp)

### 题目描述2
> 给你一个二维数组, 画一个m*m大小的矩阵, 如果一个目标在这里,给他的价值清0, 求一次炸弹怎么分布使得这个矩阵内的价值最低
### 思路概述2
> 我们可以先把价值输入到原数组，同时求出前缀和数组，之后通过前缀和还原成原数组的区间和

- [ ] [P2280](../../luogu/P2280.cpp)
## 差分

### 题目描述

> 给你一个二维数组, 每次给你一个左上角坐标和右上角坐标,在区间内给每个数加1, 求$A_{i,j}$最终有多大?


### 思路概述

原数组A, 差分数组D
- 一维差分数列公式$D_i = A_i - A_{i-1}$
- 一维差分数列还原公式$A_i = D_i + D_i-1$
> 一维差分是给差分数列的$A_i = a$后,则$D_{i}$及其之后都会加上a, 故我们想给`[l,r]`加上a,只需要$A_l=a, A_{r+1}=-a$

- 二维差分还原数列公式$A_{i,j} = D_{i-1,j-1} + D_{i,j} - D_{i-1,j} - D{i,j-1}$
> 二维差分是给差分数列$A_{i,j}$赋值a后, 则原数组$A_{i,j}$及其右下部分都会加上a, 故我们想给矩阵$左上角{x_1,y_1}右下角{x_2,y_2}$都加上a, 只需要给差分序列的$A_{x_1,y_1} = a, A_{x_2,y_1 + 1} = -a, A_{x_1 + 1,y_2} = -a, A_{x_2 + 1,y_2 + 1} = a$即可,差分数列还原公式$A_{i,j} = a_{i,j} - a_{i-1,j} - a_{i,j-1} + a_{i-1,j-1}跟前缀和的符号恰好相反$
> 总结发现, 原本需要$O(n^2)$变成了$O(1)$


### 示例代码

- [x] [P3397](../../luogu/P3397.cpp)
- [ ] [P4552](../../luogu/P4552.cpp)


# 递归
-[ ] [P1923](../../luogu/P1923.cpp)


# 欧拉筛, 埃拉托斯特筛

- [ ] [P1217](../../luogu/P1217.cpp)

# 回溯

> 会进行尝试与回退的策略
## 深度优先搜索

1. 到底了就直接返回不执行下面的代码
2. 剪枝叶(放置TLE)
3. 干当前节点的事情
4. 深度搜索下一个可能的节点
5. 回溯

- [ ] [P1118](../../luogu/P1118.cpp)
- [ ] [P1306](../../luogu/P1036.cpp)
- [x] [P1157](../../luogu/P1157.cpp)
- [ ] [P1706](../../luogu/P1706.cpp)


# 杂项

## 矩形旋转

- `len = 边长`
- 顺时针: $(i,j)\to(j,len-1-i)$
- 逆时针: $(i,j)\to(len-1-j, i)$
- 如果有偏移量左上角坐标$x_i, y_i$, x行号,y列号
- 顺时针: $(x_i + i, y_i+j)\to(x_i + j, y_i + len - 1 - i)$
- 逆时针: $(x_i + i, y_i+j)\to(x_i +len - 1 - j, y_i + i)$

## 康托展开
> 解决全排列数的加减
- [ ] [P1088](../../luogu/P1088.cpp)


## Catalan数
$$
C_n = \begin{cases}
1, & n=1\\
\sum_{i=0}^{n-1}C_iC_{n-1-i}, &n>0
\end{cases}
\\
1, 1, 2, 5, 14, 42, \dots\\
14 = 1*5 + 1*2 + 2*1 + 5*1
$$
> 把问题$C_n$拆解成问题$C_i$和问题$C_{n-i-1}$

- 出栈入栈
- 括号匹配
- Dyck路径(0,0)->(n,n)的路径数, 路径必须在对角线的上方
- n个节点构建二叉搜索树(BST)或者二叉树
- [P1044](../../luogu/P1044.cpp)
